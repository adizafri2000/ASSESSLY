# -*- coding: utf-8 -*-
"""ASSESLY.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18iELkuvKD_dSyKnPlWDBYc831-GgPXwS
"""

import pandas as pd
import plotly.express as px

import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
import plotly.graph_objects as go

"""# Clustering

## Clustering function
"""

'''
df = subject excel file (dataframe)
c1 = test selection 1
c2 = test selection 2
'''
def getClustering(df,c1,c2):
  # get column for clustering
  data = df[[c1,c2]]

  # apply standard scalar on data
  ss = StandardScaler()
  X = ss.fit_transform(data)

  #fit data into model
  model = KMeans(n_clusters=4, verbose=0)
  result = model.fit_predict(X)

  #get the label
  df['Performance Group'] = result.tolist()
  df['Performance Group'] = df['Performance Group'].apply(str)
  df['Performance Group'].replace({"0": "A", "1": "B", "2": "C", "3": "D"}, inplace=True)

  #display
  figClustering = px.scatter(df, x=c1, y=c2,color="Performance Group", hover_data=['Student Name',c1])
  figClustering.update_traces(marker={'size': 10})    

  return figClustering

"""# student performance individual"""

def showStudentPerformance(subject, name):
  studentData = subject.loc[subject['Student Name']==name]

  x = ['E1', 'E2', 'E3','Final']
  y = studentData.iloc[:,2:6].values.ravel()
  hoverLabel = []
  for index,i in enumerate(x):
    hoverLabel.append(i+" Marks = "+str(y[index]))

  figStudentPerformance = px.bar(x=x, y=y, labels=dict(x="Test Type", y="Marks"))
  figStudentPerformance.update_traces(marker_color="#9467BD", hovertemplate=hoverLabel)
  return figStudentPerformance

"""# Overall"""

def Overallperformance(subject, test):
  figOverall = px.box(subject, y=test, points="all",  boxmode="overlay", hover_data=["Student Name"], title=((test+" TEST RESULT") if test != 'Attendance' else (test + ' RECORDS')))
  return figOverall

def getLowPerformanceStudent(subject,test):
  median = np.median(subject[test])
  upper_quartile = np.percentile(subject[test], 75)
  lower_quartile = np.percentile(subject[test], 25)
  iqr = upper_quartile - lower_quartile
  upper_whisker = subject[test][subject[test]<=upper_quartile+1.5*iqr].max()
  lower_whisker = subject[test][subject[test]>=lower_quartile-1.5*iqr].min()

  student_below_min = subject.loc[(subject[test] < lower_whisker)]
  student_below_lower_quartile = subject.loc[(subject[test] >= lower_whisker) & (subject[test] <= lower_quartile)]
  
  return student_below_min, student_below_lower_quartile

"""# Performance by class"""

def performanceByClass(subject, test):
  figOverallbyClass = px.box(subject,x="Class", y=test, points="all",  boxmode="overlay", hover_data=["Student Name"],color="Class", title=((test+" TEST RESULT") if test != 'Attendance' else (test + ' RECORDS')))
  return figOverallbyClass

# Get average by class
def getAverageByClass(subject, test):
  return subject.groupby('Class').mean()[test].reset_index()

"""# Performance by Test"""
def perFormancebyTest(subject):
  fig = go.Figure()
  col = ['E1','E2','E3']
  for x in col:
    fig.add_trace(go.Box(y=subject[x].values,  name=subject[x].name))
    fig.update_layout( yaxis_title='Test Marks',)
    fig.update_traces(boxpoints='all', jitter=0)
  return fig

# Get Average by test
def getPerformancebyTest(subject):
  E1avg = subject['E1'].mean()
  E2avg = subject['E2'].mean()
  E3avg = subject['E3'].mean()
  E1min = subject['E1'].min()
  E2min = subject['E2'].min()
  E3min = subject['E3'].min()
  E1max = subject['E1'].max()
  E2max = subject['E2'].max()
  E3max = subject['E3'].max()
  testName = np.array(['E1','E2','E3'])
  testTopic = np.array(['1','2,3','4'])
  testAvg = np.array([E1avg,E2avg,E3avg])
  testMin = np.array([E1min,E2min,E3min])
  testMax = np.array([E1max,E2max,E3max])
  df = pd.DataFrame(testName, columns = ['Test'])
  df['Topics'] = testTopic.tolist()
  df['Average'] = testAvg.tolist()
  df['Min'] = testMin.tolist()
  df['Max'] = testMax.tolist()
  return df